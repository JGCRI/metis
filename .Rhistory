if(!is.null(raster::intersect(raster::extent(r), raster::extent(shapeExpandExtent)))){
rcrop<-raster::crop(r,shapeExpandExtent)
rcropP<-raster::rasterToPolygons(rcrop)
sp::proj4string(rcropP)<-sp::proj4string(shape)
rcropPx<-raster::intersect(shape,rcropP)
gridCropped<-dplyr::bind_rows(gridCropped,tibble::as_tibble(rcropP@data))
# Save gridCropped to csv
if(nrow(gridCropped)>0){
gridCroppedX<-tidyr::gather(gridCropped,key=key,value=value,-c(lat,lon))%>%
tidyr::separate(col="key",into=namesGrid[!namesGrid %in% c("lat","lon","value")],sep="_")%>%
unique()%>%
dplyr::filter(!is.na(value))
for(colx in names(gridCroppedX)){
if(is.character(gridCroppedX[[colx]])){
gridCroppedX[[colx]]<-gsub("XSPACEX"," ",gridCroppedX[[colx]])
gridCroppedX[[colx]]<-gsub("XPERIODX","\\.",gridCroppedX[[colx]])
gridCroppedX[[colx]]<-gsub("XDASHX","\\-",gridCroppedX[[colx]])
gridCroppedX[[colx]]<-gsub("XLPARENTHX","\\(",gridCroppedX[[colx]])
gridCroppedX[[colx]]<-gsub("XRLPARENTHX","\\)",gridCroppedX[[colx]])
gridCroppedX[[colx]]<-gsub("XUNDERX","\\_",gridCroppedX[[colx]])
}
}
polyType=subRegType
if (!dir.exists(paste(dirOutputs, "/Grids", sep = ""))){dir.create(paste(dirOutputs, "/Grids", sep = ""))}
if (!dir.exists(paste(dirOutputs, "/Grids/temp", sep = ""))){dir.create(paste(dirOutputs, "/Grids/temp", sep = ""))}
grid_fname<-paste(dirOutputs, "/Grids/temp/gridCropped_",boundaryRegionsSelect,"_",polyType,"_",param_i,"_",scenario_i,nameAppend,".csv", sep = "")
data.table::fwrite(gridCroppedX%>%dplyr::mutate(region=boundaryRegionsSelect,polyType=polyType),
file = grid_fname,row.names = F)
print(paste("Subregional grid data files written to: ",grid_fname, sep = ""))
} # If nrow(gridCropped)
if(is.null(gridPolyLoop)){
print("Printing Grid overlay...")
metis.map(labelsSize=labelsSize, dataPolygon=rcropPx,fileName = paste(boundaryRegionsSelect,"_",subRegType,"_map_GridSize_Labels",nameAppend,sep=""),
dirOutputs = dir,
overLayer = metis.map(labelsSize=labelsSize, dataPolygon=shape,fillColumn = subRegCol,
fillPalette = "white",alpha=0,facetsON=F,
labels=T,printFig=F),facetsON=F)
print("Printing Grid overlay with Labels...")
metis.map(labelsSize=labelsSize, dataPolygon=rcropPx,fileName = paste(boundaryRegionsSelect,"_",subRegType,"_map_GridSize",nameAppend,sep=""),
dirOutputs = dir,
overLayer = metis.map(labelsSize=labelsSize, dataPolygon=shape,fillColumn = subRegCol,
fillPalette = "white",alpha=0,facetsON=F,
labels=F,printFig = F),facetsON=F)
}
gridPolyLoop=1; # To prevent gridded map being produced multiple times
if(aggType_i=="depth"){
print(paste("Aggregating depth for parameter ", param_i," and scenario: ",scenario_i,"...",sep=""))
rcropPx@data$area<-raster::area(rcropPx)
s1<-shape
s1$subRegAreaSum<-raster::area(shape);
s1<-s1@data%>%dplyr::select( subRegCol,subRegAreaSum);
rcropPx@data<-dplyr::left_join(rcropPx@data,s1,by= subRegCol)
rcropPx@data$areaPrcnt<-rcropPx@data$area/rcropPx@data$subRegAreaSum;
x<-data.frame(mapply(`*`,rcropPx@data%>%
dplyr::select(names(rcropPx@data)[!names(rcropPx@data) %in% c(
names(shape),"lat","lon","area","subRegAreaSum","areaPrcnt")]),
rcropPx@data%>%dplyr::select(areaPrcnt),SIMPLIFY=FALSE))%>%
dplyr::bind_cols(rcropPx@data%>%dplyr::select( subRegCol))%>%tibble::as_tibble();
polyDatax<-x%>%dplyr::group_by(.dots = list( subRegCol))%>% dplyr::summarise_all(dplyr::funs(round(mean(.,na.rm=T),2)))
}
if(aggType_i=="vol"){
print(paste("Aggregating volume for parameter ", param_i," and scenario: ",scenario_i,"...",sep=""))
w <- raster::extract(r,shape, method="simple",weights=T, normalizeWeights=F);
dfx<-data.frame()
for (i in seq(w)){
if(!is.null(w[[i]])) {
x<-as.data.frame(w[[i]]) %>% dplyr::mutate(weight=weight*100)
x$ID<-shape@data[[ subRegCol]][[i]]
x1<-data.frame(mapply(`*`,x%>%
dplyr::select(names(r)[!names(r) %in% c("lat","lon")]),x%>%
dplyr::select(weight),SIMPLIFY=FALSE))%>%
dplyr::bind_cols(x%>%dplyr::select(ID));
#assign(paste0("df", i), x)
dfx<-rbind.data.frame(dfx,x1)
}
}
names(dfx)[names(dfx)=="ID"]<- subRegCol;
polyDatax<-dfx%>%dplyr::group_by(.dots = list( subRegCol))%>% dplyr::summarise_all(dplyr::funs(round(sum(.,na.rm=T),2)))%>%tibble::as_tibble()
}
polyData<-tidyr::gather(polyDatax,key=key,value=value,-(subRegCol))%>%
tidyr::separate(col="key",into=namesGrid[!namesGrid %in% c("lat","lon","value")],sep="_")
for(colx in names(polyData)){
if(is.character(polyData[[colx]])){
polyData[[colx]]<-gsub("XSPACEX"," ",polyData[[colx]])
polyData[[colx]]<-gsub("XPERIODX","\\.",polyData[[colx]])
polyData[[colx]]<-gsub("XDASHX","\\-",polyData[[colx]])
polyData[[colx]]<-gsub("XLPARENTHX","\\(",polyData[[colx]])
polyData[[colx]]<-gsub("XRLPARENTHX","\\)",polyData[[colx]])
polyData[[colx]]<-gsub("XUNDERX","\\_",polyData[[colx]])
}
}
polyData<-polyData%>%dplyr::mutate(subRegType=subRegType)
polyx<-shape
polyx@data<-dplyr::left_join(polyx@data,polyData)
polyx@data<-polyx@data%>%
dplyr::rename(subRegion:= !!paste(subRegCol))%>%
dplyr::mutate(region=boundaryRegionsSelect)%>%
dplyr::filter(!is.na(x))
poly<-dplyr::bind_rows(poly,polyx@data)
#rm(r,spdf,gridx,rcropPx,rcropP,polyx,rcrop,polyDatax)
} else { # Close loop for if extents overlap
print(paste("Gridded data provided for param: ",param_i," and scenario: ",scenario_i," did not overlap with shape boundary.",sep=""))
}
} # Close loop for aggType
} else {print(paste("No data for param: ",param_i," and scenario: ",scenario_i,".",sep=""))}# Close loop for nrow>0
} # Close loop for param_i and scenario_i
print(paste("Aggregation for all scenarios and params complete."))
}else{print("No grid provided.")}
#----------------
# Save template, csv and .RDATA
#---------------
if(nrow(poly)>0){
if (!dir.exists(paste(getwd(),"/dataFiles", sep = ""))){
dir.create(paste(getwd(),"/dataFiles", sep = ""))}  # dataFiles directory (should already exist)
if (!dir.exists(paste(getwd(),"/dataFiles/mapping", sep = ""))){
dir.create(paste(getwd(),"/dataFiles/mapping", sep = ""))}  # mapping directory
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(param,units,class,classPalette),
file = paste(getwd(),"/dataFiles/mapping/template_subRegional_mapping.csv", sep = ""),row.names = F)
for (boundaryRegionsSelect in boundaryRegionsSelect[(boundaryRegionsSelect %in% unique(poly$region))]) {
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(scenario,param,units,class,value,x,subRegion,subRegType,region)%>%
dplyr::mutate(value=0,x=2015)%>%unique,
file = paste(dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_",subRegType,"_template",nameAppend,".csv", sep = ""),row.names = F)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(dplyr::contains("scenario"),param,units,class,value,x,subRegion,subRegType,region,classPalette),
file = paste(dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""),row.names = F)
}
print(paste("Subregional Polygon template .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_template",nameAppend,".csv", sep = ""))
print(paste("Subregional Polygon data .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""))
}else{print("Polygon data has 0 rows")}
# Save Cropped Grid
if(length(list.files(paste(dirOutputs, "/Grids/temp", sep = "")))>0){
#gridCroppedCompiled <- tibble::tibble()
grid_fnameComp<-paste(dirOutputs, "/Grids/gridCropped_",boundaryRegionsSelect,"_",subRegType,nameAppend,".csv", sep = "")
gridTempX <- tibble::tibble()
for (file_i in list.files(paste(dirOutputs, "/Grids/temp", sep = ""))){
print(paste("Compiling grid file",file_i,"...",sep=""))
gridTemp <- data.table::fread(paste(dirOutputs, "/Grids/temp/",file_i, sep = ""))
gridTempX <- gridTempX %>%
dplyr::bind_rows(gridTemp)
}
gridTempAll <- gridTempX%>%unique()
if (file.exists(grid_fnameComp)){unlink(grid_fnameComp,recursive = T)}
data.table::fwrite(gridTempAll,
file = grid_fnameComp,row.names = F, append=F)
print(paste("Subregional grid data files written to: ",grid_fnameComp, sep = ""))
# Delete temporary grid folder
if (dir.exists(paste(dirOutputs, "/Grids/temp", sep = ""))){unlink(paste(dirOutputs, "/Grids/temp", sep = ""),recursive = T)}
}
return(poly)
} # Close Function
a<-data.frame(x=c(1,2,3))
a<-a%>%dplyr::select(-d)
a<-a%>%dplyr::select(-"d")
"region" %in% names(gridx)
names(gridx)
library(metis)
devtools::check()
biaInputsFolder = "NA"
biaInputsFiles = "NA"
biaOutputsFolder = paste(getwd(),"/dataFiles/grids/bia/biaOutputs",sep="")
reReadData = 1
regionsSelect = NULL
dataProj = "dataProj.proj"
dataProjPath = gcamdatabasePath
scenOrigNames = c("GCAMOrig","GCAMModified")
scenNewNames = c("GCAMOrig","GCAMModified")
gcamdatabasePath = "NA"
gcamdatabaseName = "NA"
queryxml = "metisQueries.xml"
queryPath = gcamdatabasePath
queriesSelect = "All"
paramsSelect = c("elecByTech", "elecCapBySubsector")
gridChoice = "grid_050"
diagnosticsON = T
subsectorNAdistribute = "even"
dirOutputs=paste(getwd(),"/outputs",sep="")
if (!dir.exists(dirOutputs)){                                        #these directory checks and creation I coped out of grid2poly
dir.create(dirOutputs)}
if (!dir.exists(paste(dirOutputs, "/Grids", sep = ""))){
dir.create(paste(dirOutputs, "/Grids", sep = ""))}
if (!dir.exists(paste(dirOutputs, "/Grids/diagnostics",sep=""))){
dir.create(paste(dirOutputs, "/Grids/diagnostics",sep=""))}
biaOutputsFolder=paste(getwd(),"/dataFiles/grids/bia/biaOutputs",sep="")
biaInputsFolder=paste(getwd(),"/dataFiles/grids/bia/biaInputs",sep="")
#gcamdatabasePath <-paste(getwd(),"/dataFiles/gcam",sep="")
#gcamdatabaseName <-"example_database_basexdb"
# GCAM uruguay
gcamdatabasePath <-paste("D:/GCAM/gcam-core_LAC/output",sep="")
gcamdatabaseName <-"database_basexdb"
dataProjPath<-gcamdatabasePath
queryPath<-gcamdatabasePath
#gcamdataProjFile <-"Example_dataProj.proj"
#dataProj=gcamdataProjFile  #andym
#scenOrigNames=c("ExampleScen1","ExampleScen2")
#scenNewNames=c("Eg1","Eg2")
queryxml="metisQueries.xml"
queriesSelect = "All"      #andym
#regionsSelect <- c('Argentina','Japan')
#regionsSelect <- c('Argentina', 'Colombia')
regionsSelect <- c('Uruguay')
# regionsSelect <- c('Colombia')
#regionsSelect <- c('Argentina')
paramsSelect<- c("elecByTech", "elecCapBySubsector")
reReadData=T
biaInputsFiles=c("global_power_plant_database_MW")
#biaScenarioAssign="Eg1"
#gridChoice<-"grid_050"
gridChoice<-"grid_025"
diagnosticsON<-T
#diagnosticsON<-T
subsectorNAdistribute = "totalOther"
NULL -> lat -> lon -> latitude -> longitude -> aez_id -> region_id ->X..ID->
ilon->ilat->param->V2->V3->scenario->classPalette->x->value->id->
biaYears->commonYears->commonScenarios->V1->Area_hec->Area_km2->valueBia->commonYears_i->
country->name->country_long_gppd_idnr->fuel1->fuel2->fuel3->fuel4->owner->geolocation_source->
GCMRCP->capacity_gw->capacity_mw->cf1971to2100->class1->data_source->dataBia->est_installed_capacity->
estimated_generation_gwh->gcamCapacityFactor->generation_gwh_2013->generation_gwh_2014->
generation_gwh_2015->generation_gwh_2016->
owner->region->regionsSelectAll->rowid->country_long->gppd_idnr->
vintage -> year -> xLabel -> x -> value -> sector -> scenario -> param -> origX -> origValue ->
origUnits -> origScen -> origQuery -> classPalette2 -> classPalette1 -> classLabel2 -> classLabel1 -> class2 ->
class1 -> connx -> aggregate -> Units -> sources -> paramx -> technology -> input -> output -> gcamCapacityFactor ->
gridlat -> gridlon -> gridID -> region_32_code -> ctry_name -> ctry_code -> gridCellPercentage -> aggregate ->
valueDistrib -> origValueDistrib ->readgcamdata->gridlat->gridlon->gridCropped
if(!subsectorNAdistribute %in% c("even","totalOther")){
print(paste("subsectorNAdistribute provided: ",subsectorNAdistribute," should be either 'even' or 'totalOther'. Setting to 'even'.",sep=""))
subsectorNAdistribute = "even"
}
if (!dir.exists(paste(getwd(),"/dataFiles",sep=""))){
dir.create(paste(getwd(),"/dataFiles",sep=""))}
if (!dir.exists(paste(getwd(),"/dataFiles/grids",sep=""))){
dir.create(paste(getwd(),"/dataFiles/grids",sep=""))}
if (!dir.exists(paste(getwd(),"/dataFiles/grids/bia",sep=""))){
dir.create(paste(getwd(),"/dataFiles/grids/bia",sep=""))}
if (!dir.exists(paste(getwd(),"/dataFiles/grids/bia/biaOutputs",sep=""))){
dir.create(paste(getwd(),"/dataFiles/grids/bia/biaOutputs",sep=""))}
biaOutputsFolder <- paste(getwd(),"/dataFiles/grids/bia/biaOutputs",sep="")
if (dir.exists(paste(biaOutputsFolder, "/biadiagnostics",sep=""))){
unlink(paste(biaOutputsFolder, "/biadiagnostics",sep=""),recursive=T)}
if (!dir.exists(paste(biaOutputsFolder, "/biadiagnostics",sep=""))){
dir.create(paste(biaOutputsFolder, "/biadiagnostics",sep=""))}
readgcamdata<-metis.readgcam(gcamdatabasePath = gcamdatabasePath, gcamdatabaseName = gcamdatabaseName,
queryxml = queryxml, queryPath = queryPath,
scenOrigNames = scenOrigNames, scenNewNames = scenNewNames, reReadData = reReadData,
dataProj = gcamdataProjFile, dataProjPath = dataProjPath, dirOutputs = biaOutputsFolder,
regionsSelect = regionsSelect, queriesSelect = queriesSelect , paramsSelect = paramsSelect)
queryPath<-paste(getwd(),"/dataFiles/gcam",sep="")
readgcamdata<-metis.readgcam(gcamdatabasePath = gcamdatabasePath, gcamdatabaseName = gcamdatabaseName,
queryxml = queryxml, queryPath = queryPath,
scenOrigNames = scenOrigNames, scenNewNames = scenNewNames, reReadData = reReadData,
dataProj = gcamdataProjFile, dataProjPath = dataProjPath, dirOutputs = biaOutputsFolder,
regionsSelect = regionsSelect, queriesSelect = queriesSelect , paramsSelect = paramsSelect)
gcamdataProjFile
dataProj = "dataProj.proj"
readgcamdata<-metis.readgcam(gcamdatabasePath = gcamdatabasePath, gcamdatabaseName = gcamdatabaseName,
queryxml = queryxml, queryPath = queryPath,
scenOrigNames = scenOrigNames, scenNewNames = scenNewNames, reReadData = reReadData,
dataProj = dataProj, dataProjPath = dataProjPath, dirOutputs = biaOutputsFolder,
regionsSelect = regionsSelect, queriesSelect = queriesSelect , paramsSelect = paramsSelect)
scenOrigNames=c("IDBUruguay_GCAMOrig", "IDBUruguay_GCAMRef")
scenNewNames=c("GCAMOrig","GCAMRef")
queryPath = paste(getwd(),"/dataFiles/gcam",sep="")
scenOrigNames=c("IDBUruguay_GCAMOrig", "IDBUruguay_GCAMRef")
scenNewNames=c("GCAMOrig","GCAMRef")
readgcamdata<-metis.readgcam(gcamdatabasePath = gcamdatabasePath, gcamdatabaseName = gcamdatabaseName,
queryxml = queryxml, queryPath = queryPath,
scenOrigNames = scenOrigNames, scenNewNames = scenNewNames, reReadData = reReadData,
dataProj = dataProj, dataProjPath = dataProjPath, dirOutputs = biaOutputsFolder,
regionsSelect = regionsSelect, queriesSelect = queriesSelect , paramsSelect = paramsSelect)
# Save list of scenarios and queries
scenarios <- readgcamdata$scenarios  # List of Scenarios in the GCAM database pulled in through metis.readgcam
queries <- readgcamdata$queries  # List of Queries in the GCAM database pulled in through metis.readgcam
if(length(queries)==0){stop("No queries found. PLease check data.")}
dataFromGCAM <- readgcamdata$data%>%
tibble::as_tibble()
dataFromGCAM
regionsSelect
#tbl <- rgcam::getQuery(dataProjLoaded, queries[1])  # Tibble
regionsAll<-unique(dataFromGCAM$region)
if(("All" %in% regionsSelect) | ("all" %in% regionsSelect) | is.null(regionsSelect)){regionsSelect<-regionsAll; regionsSelectAll=T}else{
regionsSelectAll=F
}
# Loading a list that gives which of the 32 regions each country is in
ctor<-data.table::fread(file=paste(biaInputsFolder,"/country_to_region.csv",sep=""), header=T,stringsAsFactors = F)%>%
tibble::as_tibble()%>%
dplyr::mutate(country_long=ctry_name)
ctor
ctor%>%as.data.frame()
ctor%>%filter(region=="Uruguay")
listOfGridCells<-data.table::fread(file=paste(getwd(),"/dataFiles/grids/emptyGrids/",gridChoice,".csv",sep=""), header=T,stringsAsFactors = F)%>%
tibble::as_tibble()
if(!("id" %in% names(listOfGridCells))){
print("grid id column not found within grid file, creating a new id column...")
listOfGridCells <- rowid_to_column(listOfGridCells, var = "id")
}
listOfGridCells <- rename(listOfGridCells,
gridlat = lat,
gridlon = lon,
gridID = id)
latmin<-min(listOfGridCells$gridlat)
latmax<-max(listOfGridCells$gridlat)
lonmin<-min(listOfGridCells$gridlon)
lonmax<-max(listOfGridCells$gridlon)
latranked<-listOfGridCells$gridlat[sort.list(listOfGridCells$gridlat)]%>%
unique()
lonranked<-listOfGridCells$gridlon[sort.list(listOfGridCells$gridlon)]%>%
unique()
# This assumes equally spaced grids by degree.
gridDimlat<-min(abs(latranked[2:length(latranked)]-latranked[1:length(latranked)-1]))
gridDimlon<-min(abs(lonranked[2:length(lonranked)]-lonranked[1:length(lonranked)-1]))
gridShiftlat<-latranked[sort.list(abs(latranked))][1]  # The latitude of the center of the grid cells closest to the equator
gridShiftlon<-lonranked[sort.list(abs(lonranked))][1]  # The longitude of the center of the grid cells closest to prime meridian, Greenwich Meridian
listOfGridCells$gridlat<-round(listOfGridCells$gridlat, digits = 10)
listOfGridCells$gridlon<-round(listOfGridCells$gridlon, digits = 10)
if(!(sum(round(latranked, digits = 4) %in% round(seq(latmin,latmax,length.out = (round((latmax-latmin)/gridDimlat)+1)),digits = 4))==length(latranked))){
stop(paste("grid file ", getwd(),"/dataFiles/grids/emptyGrids/",gridChoice,".csv"," does not appear to contain the centers of regurlarly-spaced lat lon grid cells.",sep=""))}
!dir.exists(biaInputsFolder)
biaYears<-numeric()
biaInputsFile_i
biaInputsFiles
biaInputsFile_i<-biaInputsFile
biaInputsFile_i<-biaInputsFiles
if(!grepl(".csv",biaInputsFile_i)){biaInputsFile_i=paste(biaInputsFile_i,".csv",sep="")}
!file.exists(paste(biaInputsFolder,"/",biaInputsFile_i,sep=""))
print(paste("Reading bia input file: ",biaInputsFile_i,"...",sep=""))
gridWRI<-data.table::fread(paste(biaInputsFolder,"/",biaInputsFile_i,sep=""), header=T,stringsAsFactors = F)
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("United States",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("United States",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Bosnia",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Bosnia",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Brunei",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Brunei",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI=="Democratic Republic of the Congo"]<-"Congo DRC"
gridWRI[gridWRI=="Congo"]<-"Congo Rep."
gridWRI[gridWRI=="Taiwan"]<-"Taiwan China"
ctor$country_long[ctor$region == "Taiwan"] <- "Taiwan China"
gridWRI[gridWRI=="Congo"]<-"Congo Rep."
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Cote",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Cote",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Gambia",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Gambia",unique(ctor$country_long),ignore.case=T)]
# gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Kosovo",unique(gridWRI$country_long),ignore.case=T)]]<-
#   unique(ctor$country_long)[grepl("Kosovo",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Syria",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Syria",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Taiwan",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Taiwan",unique(ctor$country_long),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$country_long)[grepl("Trinidad",unique(gridWRI$country_long),ignore.case=T)]]<-
unique(ctor$country_long)[grepl("Trinidad",unique(ctor$country_long),ignore.case=T)]
gridWRI<-gridWRI%>%tibble::as_tibble()%>%dplyr::select(-year_of_capacity_data,-commissioning_year,-name,-country,-gppd_idnr,-fuel2,-fuel3,-fuel4,-owner,-source,-url,-geolocation_source)%>%
dplyr::left_join(ctor,by="country_long")
gridWRI
biaGCM = NA;biaRCP = NA
aggType="vol"
gridWRI<-gridWRI%>%dplyr::mutate(lat=latitude,
lon=longitude,
param="biaElecGen",
units= "Capacity (GW)",
aggType=aggType,
classPalette="pal_elec_subsec",
class1=fuel1,
value=capacity_mw/1000,
x=NA,
gridlat = round(gridDimlat*round(latitude*(1/gridDimlat)-(gridShiftlat/gridDimlat))+gridShiftlat, digits = 10),
gridlon = round(gridDimlon*round(longitude*(1/gridDimlon)-(gridShiftlon/gridDimlon))+gridShiftlon, digits = 10))%>%
tibble::as_tibble()%>%
dplyr::select(-latitude,-longitude,-fuel1,-capacity_mw,-generation_gwh_2013,-generation_gwh_2014,-generation_gwh_2015,-generation_gwh_2016,-estimated_generation_gwh,-country_long)%>%
dplyr::left_join(listOfGridCells,by = c("gridlat","gridlon"))%>%
dplyr::group_by(gridlat, gridlon, class1, gridID, ctry_name, ctry_code, region, region_32_code, param, units)%>%
dplyr::summarise(gridCellCapacity = sum(value))%>%
dplyr::ungroup() %>%
dplyr::group_by(class1,region,region_32_code)%>%
dplyr::mutate(regionCapSum = sum(gridCellCapacity),
gridCellPercentage = gridCellCapacity/regionCapSum) %>%
dplyr::ungroup()
gridWRI
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("cogen",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("chp",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("coal",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("coal",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Gas",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Gas",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Oil",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Oil",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Biomass",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Biomass",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Nuclear",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Nuclear",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Geothermal",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Geothermal",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Hydro",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Hydro",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Wind",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Wind",unique(dataFromGCAM$class1),ignore.case=T)]
gridWRI[gridWRI==unique(gridWRI$class1)[grepl("Solar",unique(gridWRI$class1),ignore.case=T)]]<-
unique(dataFromGCAM$class1)[grepl("Solar",unique(dataFromGCAM$class1),ignore.case=T)]
if(subsectorNAdistribute == "even"){
#-------------------
# For electricity generation subsectors not represented in power plant database, distribute evently throughout region
#-------------------
# Read in GCAM regions
if(!dir.exists(paste(getwd(),"/dataFiles/gis/admin_gcam32",sep=""))){
print(paste("GCAMRegionShapeFolder: ",paste(getwd(),"/dataFiles/gis/admin_gcam32",sep=""), " does not exist.",sep=""))
} else{
GCAMRegionShapeFolder <- paste(getwd(),"/dataFiles/gis/admin_gcam32",sep="")}
if(!file.exists(paste(getwd(),"/dataFiles/gis/admin_gcam32/region32_0p5deg.shp",sep=""))){
print(paste("GCAMRegionShapeFolder: ",paste(getwd(),"/dataFiles/gis/admin_gcam32/region32_0p5deg.shp",sep=""), " does not exist.",sep=""))
} else{
GCAMRegionShapeFile <- "region32_0p5deg"}
gridCropped <- tibble(gridlat = NA, gridlon = NA, gridID = NA, region = NA)
for(regionc in regionsSelect){
shape=rgdal::readOGR(dsn=GCAMRegionShapeFolder,layer=GCAMRegionShapeFile,use_iconv=T,encoding='UTF-8')
shape@data <-shape@data %>%
left_join(ctor %>%
dplyr::select(region_32_code, region) %>%
dplyr::distinct() %>%
dplyr::mutate(reg32_id=as.factor(region_32_code))%>%
dplyr::select(-region_32_code), by = "reg32_id")
shape@data %>% as.data.frame()
shape <- shape[(shape$region %in% regionc),];
plot(shape)
# Prepare grids to be cropped
spdf = sp::SpatialPointsDataFrame(sp::SpatialPoints(coords=(cbind(listOfGridCells$gridlon,listOfGridCells$gridlat))),data=listOfGridCells)
sp::gridded(spdf)<-TRUE
r<-raster::stack(spdf)
raster::projection(r)<-sp::proj4string(shape)
rmask<-raster::mask(r,shape)
rmaskP<-raster::rasterToPolygons(rmask)
gridCropped<-dplyr::bind_rows(gridCropped,dplyr::mutate(tibble::as_tibble(rmaskP@data),region = regionc))
}
gridCropped <- dplyr::filter(gridCropped,!is.na(region))
dataBia<- dataFromGCAM %>%
dplyr::left_join(
gridWRI%>%dplyr::filter(region %in% regionsSelect)%>%
dplyr::select(gridlat, gridlon, gridID, class1, region, region_32_code, ctry_name, ctry_code, gridCellPercentage),
by = c("class1", "region"))%>%
dplyr::mutate(valueDistrib = gridCellPercentage*value, origValueDistrib = gridCellPercentage*origValue)
dataBiaNA <- dplyr::filter(dataBia,is.na(gridlat)) %>%
dplyr::select(-gridlat, -gridlon, -gridID)
evenDistrib <- expand.grid(unique(dataBiaNA$class1), gridCropped$gridID) %>%
tibble::as_tibble() %>%
dplyr::rename(class1 = Var1, gridID = Var2) %>%
dplyr::left_join(listOfGridCells, by = "gridID") %>%
dplyr::left_join(gridCropped, by = c("gridlat", "gridlon", "gridID"))
evenDistrib$class1 <- as.character(evenDistrib$class1)
evenDistrib <- dplyr::left_join(dataBiaNA,evenDistrib, by = c("class1", "region")) %>%
dplyr::mutate(gridCellCapacity = 999) %>%
dplyr::group_by(class1,region)%>%
dplyr::mutate(regionCapSum = sum(gridCellCapacity),
gridCellPercentage = gridCellCapacity/regionCapSum) %>%
dplyr::ungroup() %>%
dplyr::select(-valueDistrib, -origValueDistrib) %>%
dplyr::mutate(valueDistrib = gridCellPercentage*value, origValueDistrib = gridCellPercentage*origValue)%>%
dplyr::select(-gridCellCapacity, -regionCapSum)
dataBia <- dataBia %>%
dplyr::filter(!(is.na(gridlat))) %>%
bind_rows(evenDistrib)
} # Close if subsectorNAdistribute == "even"
subsectorNAdistribute
if(subsectorNAdistribute == "totalOther"){
#-------------------
# For electricity generation subsectors not represented in power plant database, distribute according to installed capacity of all subsectors
#-------------------
gridWRIallSubsecMixed <- gridWRI %>%
dplyr::group_by(gridlat, gridlon, gridID, ctry_name, ctry_code, region, region_32_code, param, units)%>%
dplyr::summarise(gridCellCapacity = sum(gridCellCapacity))%>%
dplyr::ungroup() %>%
dplyr::group_by(region,region_32_code)%>%
dplyr::mutate(regionCapSum = sum(gridCellCapacity),
gridCellPercentage = gridCellCapacity/regionCapSum) %>%
dplyr::ungroup() %>%
rowid_to_column(var = "gridCellIndex") %>%
dplyr::mutate(gridCellIndex = -gridCellIndex)
dataBia<- dataFromGCAM %>%
dplyr::left_join(
gridWRI%>%dplyr::filter(region %in% regionsSelect)%>%
dplyr::select(gridlat, gridlon, gridID, class1, region, region_32_code, ctry_name, ctry_code, gridCellPercentage),
by = c("class1", "region"))%>%
dplyr::mutate(valueDistrib = gridCellPercentage*value, origValueDistrib = gridCellPercentage*origValue)
#Find the elecricity generation subsectors that are not represented in the powerplant database, but which are predicted by GCAM
dataBiaNA <- dplyr::filter(dataBia,is.na(gridlat)) %>%
dplyr::select(-gridlat, -gridlon, -gridID, -region_32_code, -ctry_name, -ctry_code, -gridCellPercentage)
distribByTotalCap <- expand.grid(unique(dataBiaNA$class1), (dplyr::filter(gridWRIallSubsecMixed, region %in% regionsSelect))$gridCellIndex) %>%
tibble::as_tibble() %>%
dplyr::rename(class1 = Var1, gridCellIndex = Var2) %>%
dplyr::mutate(class1 = as.character(class1)) %>%
dplyr::left_join(gridWRIallSubsecMixed, by = "gridCellIndex") %>%
dplyr::select(-param, -units)
distribByTotalCap <- dplyr::left_join(dataBiaNA, distribByTotalCap, by = c("class1", "region")) %>%
dplyr::select(-valueDistrib, -origValueDistrib) %>%
dplyr::mutate(valueDistrib = gridCellPercentage*value, origValueDistrib = gridCellPercentage*origValue)
dataBia <- dataBia %>%
dplyr::filter(!(is.na(gridlat))) %>%
bind_rows(dplyr::select(distribByTotalCap, -regionCapSum, -gridCellCapacity, -gridCellIndex))
} # Close if subsectorNAdistribute == "totalOther"
dataBia
dataBia%>%as.data.frame()
?rowid_to_column
tibble::tibble(gridlat = NA, gridlon = NA, gridID = NA, region = NA)
?plot
plot(shape)
graphics::plot(shape)
raster::plot(shape)
dev.off()
dev.off()
dev.off()
raster::plot(shape)
library(metis)
devtools::check()
devtools::check()
