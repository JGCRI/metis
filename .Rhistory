polyData[[colx]]<-gsub("XLPARENTHX","\\(",polyData[[colx]])
polyData[[colx]]<-gsub("XRLPARENTHX","\\)",polyData[[colx]])
polyData[[colx]]<-gsub("XUNDERX","\\_",polyData[[colx]])
}
}
head(polyData)
names(polyData)
names(polyData)
for(colx in names(polyData)){
polyData[[colx]]<-gsub("XSPACEX"," ",polyData[[colx]])
polyData[[colx]]<-gsub("XPERIODX","\\.",polyData[[colx]])
polyData[[colx]]<-gsub("XDASHX","\\-",polyData[[colx]])
polyData[[colx]]<-gsub("XLPARENTHX","\\(",polyData[[colx]])
polyData[[colx]]<-gsub("XRLPARENTHX","\\)",polyData[[colx]])
polyData[[colx]]<-gsub("XUNDERX","\\_",polyData[[colx]])
}
names(polyData)
head(x)
polyDatax<-x%>%dplyr::group_by(.dots = list( subRegCol))%>% dplyr::summarise_all(dplyr::funs(round(sum(.,na.rm=T),2)))
head(polyData)
polyDatax[1:10,1:10]
polyData<-tidyr::gather(polyDatax,key=key,value=value,-(subRegCol))%>%
tidyr::separate(col="key",into=names(gridx)[!names(gridx) %in% c("lat","lon","value")],sep="_")
nrow(polyDatax)
head(polyData)
polyData[1:10,1:10]
polyData[1:10,5:10]
polyData[1:10,10:20]
polyData<-tidyr::gather(polyDatax,key=key,value=value,-(subRegCol))
polyData[1:10,1:20]
head(polyData)
names(gridx)[!names(gridx) %in% c("lat","lon","value")]
names(sqlGrid)
a<-sqlGrid%>%dplyr::filter(param==param_i, scenario==scenario_i)%>%collect()
names(a)
namesGrid<-names(a)
namesGrid[!namesGrid %in% c("lat","lon","value")]
polyData<-tidyr::gather(polyDatax,key=key,value=value,-(subRegCol))%>%
tidyr::separate(col="key",into=namesGrid[!namesGrid %in% c("lat","lon","value")],sep="_")
polyData[1:10,1:10]
for(colx in names(polyData)){
if(is.character(polyData[[colx]])){
polyData[[colx]]<-gsub("XSPACEX"," ",polyData[[colx]])
polyData[[colx]]<-gsub("XPERIODX","\\.",polyData[[colx]])
polyData[[colx]]<-gsub("XDASHX","\\-",polyData[[colx]])
polyData[[colx]]<-gsub("XLPARENTHX","\\(",polyData[[colx]])
polyData[[colx]]<-gsub("XRLPARENTHX","\\)",polyData[[colx]])
polyData[[colx]]<-gsub("XUNDERX","\\_",polyData[[colx]])
}
}
polyData<-polyData%>%dplyr::mutate(subRegType=subRegType)
polyx<-shape
polyx@data<-dplyr::left_join(polyx@data,polyData)
polyx@data<-polyx@data%>%
dplyr::rename(subRegion:= !!paste(subRegCol))%>%
dplyr::mutate(region=boundaryRegionsSelect)%>%
dplyr::filter(!is.na(x))
poly<-dplyr::bind_rows(poly,polyx@data)
head(poly)
poly@data[1:10,1:10]
poly[1:10,1:10]
poly[1:10,10:20]
poly[1:10,20:30]
poly[1:10,40:50]
poly[1:10,50:60]
poly[1:10,100:110]
ncol(poly)
(poly%>%filter(poly[,129]>0))[1:10,120:129]
names(poly)
(poly%>%filter(value>0))[1:10,118:129]
(poly%>%filter(value>0))[1:10,110:129]
gridCropped<-tidyr::gather(gridCropped,key=key,value=value,-c(lat,lon))%>%
tidyr::separate(col="key",into=namesGrid[!namesGrid %in% c("lat","lon","value")],sep="_")%>%
unique()
for(colx in names(gridCropped)){
if(is.character(gridCropped[[colx]])){
gridCropped[[colx]]<-gsub("XSPACEX"," ",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XPERIODX","\\.",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XDASHX","\\-",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XLPARENTHX","\\(",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XRLPARENTHX","\\)",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XUNDERX","\\_",gridCropped[[colx]])
}
}
polyType=subRegType
if (!dir.exists(paste(dirOutputs, "/Grids", sep = ""))){dir.create(paste(dirOutputs, "/Grids", sep = ""))}
data.table::fwrite(gridCropped%>%dplyr::mutate(region=boundaryRegionsSelect,polyType=polyType),
file = paste(dirOutputs, "/Grids/gridCropped_",boundaryRegionsSelect,"_",polyType,nameAppend,".csv", sep = ""),row.names = F)
if (!dir.exists(paste(getwd(),"/dataFiles", sep = ""))){
dir.create(paste(getwd(),"/dataFiles", sep = ""))}  # dataFiles directory (should already exist)
if (!dir.exists(paste(getwd(),"/dataFiles/mapping", sep = ""))){
dir.create(paste(getwd(),"/dataFiles/mapping", sep = ""))}  # mapping directory
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(param,units,class,classPalette),
file = paste(getwd(),"/dataFiles/mapping/template_subRegional_mapping.csv", sep = ""),row.names = F)
for (boundaryRegionsSelect in boundaryRegionsSelect[(boundaryRegionsSelect %in% unique(poly$region))]) {
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(scenario,param,units,class,value,x,subRegion,subRegType,region)%>%
dplyr::mutate(value=0,x=2015)%>%unique,
file = paste(dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_",subRegType,"_template",nameAppend,".csv", sep = ""),row.names = F)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(scenario,param,units,class,value,x,subRegion,subRegType,region,classPalette),
file = paste(dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""),row.names = F)
}
print(paste("Subregional Polygon template .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_template",nameAppend,".csv", sep = ""))
print(paste("Subregional Polygon data .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""))
print(paste("Subregional grid data files written to: ",dirOutputs, "/Grids/gridCropped_",boundaryRegionsSelect,"_",polyType,nameAppend,".csv", sep = ""))
names(poly)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(dplyr::contains(scenario),param,units,class,value,x,subRegion,subRegType,region,classPalette),
file = paste(dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""),row.names = F)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(dplyr::contains("scenario"),param,units,class,value,x,subRegion,subRegType,region,classPalette),
file = paste(dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""),row.names = F)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(contains("scenario"),param,units,class,value,x,subRegion,subRegType,region)%>%
dplyr::mutate(value=0,x=2015)%>%unique,
file = paste(dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_",subRegType,"_template",nameAppend,".csv", sep = ""),row.names = F)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(scenario,param,units,class,value,x,subRegion,subRegType,region)%>%
dplyr::mutate(value=0,x=2015)%>%unique,
file = paste(dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_",subRegType,"_template",nameAppend,".csv", sep = ""),row.names = F)
print(paste("Subregional Polygon data .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""))
metis.grid2poly<- function(grid=NULL,
boundaryRegionsSelect=NULL,
subRegShape=NULL,
subRegShpFolder=NULL,
subRegShpFile=NULL,
subRegCol=NULL,
subRegType="subRegType",
aggType=NULL,
dirOutputs=paste(getwd(),"/outputs",sep=""),
nameAppend="",
labelsSize=1.2,
paramsSelect="All",
sqliteUSE = T,
sqliteDBNamePath = paste(getwd(),"/outputs/Grids/gridMetis.sqlite", sep = "")) {
# grid=NULL
# boundaryRegionsSelect=NULL
# subRegShape=NULL
# subRegShpFolder=NULL
# subRegShpFile=NULL
# subRegCol=NULL
# subRegType="subRegType"
# aggType=NULL
# dirOutputs=paste(getwd(),"/outputs",sep="")
# nameAppend=""
# labelsSize=1.2
#----------------
# Initialize variables by setting to NULL
#----------------
NULL->subRegAreaSum->areaPrcnt->weight->ID->subRegion->region->scenario->
param->shpRegCol->subReg->griddataTables->tbl->key->value->.->classPalette->lat->lon->overlapShape->
gridPolyLoop->dbHead
#----------------
# Check input data format
#---------------
if(sqliteUSE==T){
paste("Using SQLite database...",sep="")
if(!file.exists(sqliteDBNamePath)){stop("SQLite file path provided does not exist: ", sqliteDBNamePath, sep="")}
dbConn <- DBI::dbConnect(RSQLite::SQLite(), sqliteDBNamePath)
src_dbi(dbConn)
sqlGrid<-tbl(dbConn,"gridMetis"); head(sqlGrid)
dbHead<-head(sqlGrid,1)%>%collect();dbHead
names(dbHead)
if(!all(c("param","scenario","lon","lat","value") %in% names(dbHead))){
stop("SQLite database must have columns for lon, lat, value, param and scenario. Sql Database cols are : ",
paste(names(dbHead),collapse=", "), sep="")}
paste("Finding unique params in sql database...",sep="")
params<-sqlGrid%>%dplyr::distinct(param)%>%collect();
params=params$param
paste("Unique params found : ", paste(params,collapse=", "),sep="")
paste("Finding unique scenarios in sql database...",sep="")
scenarios<-sqlGrid%>%dplyr::distinct(scenario)%>%collect();
scenarios=scenarios$scenario
paste("Unique scenarios found : ", paste(scenarios,collapse=", "),sep="")
} else {
# If not using SQL database
if(!is.null(grid)){
if(all(!class(grid) %in% c("tbl_df","tbl","data.frame"))){
if(any(grepl(".csv",paste(grid)))){
print(paste("Attempting to read grid csv file ",grid,sep=""))
if(file.exists(grid)){
grid<-data.table::fread(grid)
grid<-grid%>%unique()}else{
stop(paste("Grid file ",grid," does not exist",sep=""))
}
}
}
if(any(!c("lat","lon","value","param","scenario") %in% names(grid))){
stop(paste(grid," should have columns lon, lat, value, param and scenario. Missing columns: ",
names(grid)[!names(grid) %in% c("lat","lon","value")]))
params=unique(grid$param)
scenarios=unique(grid$scenario)}
} # If !is.null(grid)
} # if not using sqlLite
#----------------
# Load Shapefile and save boundary maps
#---------------
if(is.null(subRegShape)){
if(!is.null(subRegShpFolder) & !is.null(subRegShpFile)){
if(!dir.exists(subRegShpFolder)){
stop("Shapefile folder: ", subRegShpFolder ," is incorrect or doesn't exist.",sep="")}
if(!file.exists(paste(subRegShpFolder,"/",subRegShpFile,".shp",sep=""))){
stop("Shape file: ", paste(subRegShpFolder,"/",subRegShpFile,".shp",sep="")," is incorrect or doesn't exist.",sep="")}
shape=rgdal::readOGR(dsn=subRegShpFolder,layer=subRegShpFile,use_iconv=T,encoding='UTF-8')
print(paste("Sub Reg Shape : ",subRegShpFolder,"/",subRegShpFile,".shp",sep=""))
print(raster::head(shape))
}else {
stop("No valid boundary or subregional shape file available")
}# if(!is.null(subRegShpFolder) & !is.null(subRegShpFile)){
}else{shape=subRegShape}
poly<-tibble::tibble()
if(is.null(boundaryRegionsSelect)){boundaryRegionsSelect="Region"}
#----------------
# Create Folders
#---------------
if (!dir.exists(dirOutputs)){dir.create(dirOutputs)}
if (!dir.exists(paste(dirOutputs, "/Maps", sep = ""))){dir.create(paste(dirOutputs, "/Maps", sep = ""))}
if (!dir.exists(paste(dirOutputs, "/Maps/Boundaries", sep = ""))){dir.create(paste(dirOutputs, "/Maps/Boundaries", sep = ""))}
if (!dir.exists(paste(dirOutputs, "/Maps/Boundaries/",boundaryRegionsSelect, sep = ""))){dir.create(paste(dirOutputs, "/Maps/Boundaries/",boundaryRegionsSelect,sep = ""))}
if (!dir.exists(paste(dirOutputs, "/Maps/Tables", sep = ""))){dir.create(paste(dirOutputs, "/Maps/Tables", sep = ""))}
dir=paste(dirOutputs, "/Maps/Boundaries/",boundaryRegionsSelect,sep = "")
#----------------
# Read in shapefiles and check format
#---------------
if(!is.null(sqlGrid)){
if(!any(paramsSelect == "All")){
if(all(paramsSelect %in% params)){
sqlGrid<-sqlGrid%>%dplyr::filter(param %in% paramsSelect)
print(paste("Filtering sqlGrid to selected paramsSelect ",paste(paramsSelect,collapse=", "),sep=""))
}else{
if(any(paramsSelect %in% unique(grid$param))){
grid<-grid%>%dplyr::filter(param %in% paramsSelect)
print(paste("Only analyzing params ",paste((paramsSelect %in% unique(grid$param)),collapse=", "),
" which are present in sqlGrid of all paramsSelect ",paste(paramsSelect,collapse=", "),sep=""))
}else{
print(paste("paramsSelect ",paste(paramsSelect,collapse=", "),
" not present in unique(grid$param) ",
unique(grid$param),". Using all params in sqlGrid.",sep=""))
}
}
} # closing if !is.null(grid)
}
if(!is.null(grid)){
if(!any(paramsSelect == "All")){
if(all(paramsSelect %in% params)){
grid<-grid%>%dplyr::filter(param %in% paramsSelect)
paramsSub<-params[params %in% paramsSelect]
print(paste("Filtering grid to selected paramsSelect ",paste(paramsSelect,collapse=", "),sep=""))
}else{
if(any(paramsSelect %in% params)){
grid<-grid%>%dplyr::filter(param %in% paramsSelect)
paramsSub<-params[params %in% paramsSelect]
print(paste("Only analyzing params ",paste((paramsSelect %in% params),collapse=", "),
" which are present in grid of all paramsSelect ",paste(paramsSelect,collapse=", "),sep=""))
}else{
print(paste("paramsSelect ",paste(paramsSelect,collapse=", "),
" not present in unique(grid$param) ",
params,". Using all params in grid.",sep=""))
}
}
}
}# closing if !is.null(grid)
gridCropped<-tibble::tibble()
if(!is.null(sqlGrid) | !is.null(grid)){
for (param_i in paramsSub){
for (scenario_i in scenarios){
paste("Starting aggregation for param: ",param_i," and scenario: ",scenario_i,"...",sep="")
if(!is.null(sqlGrid)){
gridx<-sqlGrid%>%dplyr::filter(param==param_i, scenario==scenario_i)%>%collect()
}else{
gridx<-grid%>%dplyr::filter(param==param_i,scenario==scenario_i)
}
if(!"aggType" %in% names(gridx)){
if(is.null(aggType)){
print("Column aggType is missing from grid data. Assigning aggType='depth'")
gridx<-gridx%>%dplyr::mutate(aggType="depth")}else{
gridx<-gridx%>%dplyr::mutate(aggType=aggType)
}}
namesGrid<-names(gridx)
# Temporary column names merge in order to aggregate params scenarios across sub-regions
print("setting grid columns ...")
for(colx in names(gridx)){
if(is.character(gridx[[colx]])){
gridx[[colx]]<-gsub(" ","XSPACEX",gridx[[colx]],perl = TRUE )
gridx[[colx]]<-gsub("\\.","XPERIODX",gridx[[colx]],perl = TRUE )
gridx[[colx]]<-gsub("\\-","XDASHX",gridx[[colx]],perl = TRUE )
gridx[[colx]]<-gsub("\\(","XLPARENTHX",gridx[[colx]],perl = TRUE)
gridx[[colx]]<-gsub("\\)","XRLPARENTHX",gridx[[colx]],perl = TRUE)
gridx[[colx]]<-gsub("\\_","XUNDERX",gridx[[colx]],perl = TRUE)
}
}
print("Grid Columns set.")
for (aggType_i in unique(gridx$aggType)){
if(!unique(gridx$aggType) %in% c("depth","vol")){stop("Incorrect aggType in grid file")}
print("Uniting columns...")
gridx<-gridx%>%dplyr::filter(aggType==aggType_i)%>%
tidyr::unite(col="key",names(gridx)[!names(gridx) %in% c("lat","lon","value")],sep="_",remove=T)
print("Columns united.")
gridx<-gridx%>%tidyr::spread(key=key,value=value)
# Convert to Spatial Point Data Frames
spdf = sp::SpatialPointsDataFrame(sp::SpatialPoints(coords=(cbind(gridx$lon,gridx$lat))),data=gridx)
sp::gridded(spdf)<-TRUE
r<-raster::stack(spdf)
raster::projection(r)<-sp::proj4string(shape)
shapeExpandExtent<-as.data.frame(sp::bbox(shape))   # Get Bounding box
expandPercent<-3; shapeExpandExtent$min;shapeExpandExtent$max
rangeX<-abs(range(shapeExpandExtent$min[1],shapeExpandExtent$max[1])[2]-range(shapeExpandExtent$min[1],shapeExpandExtent$max[1])[1])
rangeY<-abs(range(shapeExpandExtent$min[2],shapeExpandExtent$max[2])[2]-range(shapeExpandExtent$min[2],shapeExpandExtent$max[2])[1])
shapeExpandExtent$min[1]<-(-rangeX*expandPercent/100)+shapeExpandExtent$min[1];
shapeExpandExtent$min[2]<-(-rangeY*expandPercent/100)+shapeExpandExtent$min[2];
shapeExpandExtent$max[1]<-(rangeX*expandPercent/100)+shapeExpandExtent$max[1];
shapeExpandExtent$max[2]<-(rangeY*expandPercent/100)+shapeExpandExtent$max[2];
shapeExpandExtent<-methods::as(raster::extent(as.vector(t(shapeExpandExtent))), "SpatialPolygons")
sp::proj4string(shapeExpandExtent)<-sp::CRS(sp::proj4string(shape)) # ASSIGN COORDINATE SYSTEM
print(paste("Cropping grid to shape file for parameter ", param_i,"...",sep=""))
rcrop<-raster::crop(r,shapeExpandExtent)
rcropP<-raster::rasterToPolygons(rcrop)
gridCropped<-dplyr::bind_rows(gridCropped,tibble::as_tibble(rcropP@data))
sp::proj4string(rcropP)<-sp::proj4string(shape)
rcropPx<-raster::intersect(shape,rcropP)
# rcropPx covers all the area available in the rasters which intersect with the shape
#plot(rcrop[[names(rcrop)[3]]]);plot(shape,add=T)
#plot(rcropP,col="cadetblue1");plot(shape,add=T)
#plot(rcropPx,col="cadetblue1");plot(shape,add=T)
if(is.null(gridPolyLoop)){
print("Printing Grid overlay...")
metis.map(labelsSize=labelsSize, dataPolygon=rcropPx,fileName = paste(boundaryRegionsSelect,"_",subRegType,"_map_GridSize_Labels",nameAppend,sep=""),
dirOutputs = dir,
overLayer = metis.map(labelsSize=labelsSize, dataPolygon=shape,fillColumn = subRegCol,
fillPalette = "white",alpha=0,facetsON=F,
labels=T,printFig=F),facetsON=F)
print("Printing Grid overlay with Labels...")
metis.map(labelsSize=labelsSize, dataPolygon=rcropPx,fileName = paste(boundaryRegionsSelect,"_",subRegType,"_map_GridSize",nameAppend,sep=""),
dirOutputs = dir,
overLayer = metis.map(labelsSize=labelsSize, dataPolygon=shape,fillColumn = subRegCol,
fillPalette = "white",alpha=0,facetsON=F,
labels=F,printFig = F),facetsON=F)
}
gridPolyLoop=1; # To prevent gridded map being produced multiple times
if(aggType_i=="depth"){
print(paste("Aggregating depth for parameter ", param_i,"...",sep=""))
rcropPx@data$area<-raster::area(rcropPx)
s1<-shape
s1$subRegAreaSum<-raster::area(shape);
s1<-s1@data%>%dplyr::select( subRegCol,subRegAreaSum);
rcropPx@data<-dplyr::left_join(rcropPx@data,s1,by= subRegCol)
rcropPx@data$areaPrcnt<-rcropPx@data$area/rcropPx@data$subRegAreaSum;
x<-data.frame(mapply(`*`,rcropPx@data%>%
dplyr::select(names(rcropPx@data)[!names(rcropPx@data) %in% c(
names(shape),"lat","lon","area","subRegAreaSum","areaPrcnt")]),
rcropPx@data%>%dplyr::select(areaPrcnt),SIMPLIFY=FALSE))%>%
dplyr::bind_cols(rcropPx@data%>%dplyr::select( subRegCol))%>%tibble::as_tibble();
polyDatax<-x%>%dplyr::group_by(.dots = list( subRegCol))%>% dplyr::summarise_all(dplyr::funs(round(sum(.,na.rm=T),2)))
}
if(aggType_i=="vol"){
print(paste("Aggregating volume for parameter ", param_i,"...",sep=""))
w <- raster::extract(r,shape, method="simple",weights=T, normalizeWeights=F);
dfx<-data.frame()
for (i in seq(w)){
if(!is.null(w[[i]]))
x<-as.data.frame(w[[i]])
x$ID<-shape@data[[ subRegCol]][[i]]
x1<-data.frame(mapply(`*`,x%>%
dplyr::select(names(r)[!names(r) %in% c("lat","lon")]),x%>%
dplyr::select(weight),SIMPLIFY=FALSE))%>%
dplyr::bind_cols(x%>%dplyr::select(ID));
#assign(paste0("df", i), x)
dfx<-rbind.data.frame(dfx,x1)
}
names(dfx)[names(dfx)=="ID"]<- subRegCol;
polyDatax<-dfx%>%dplyr::group_by(.dots = list( subRegCol))%>% dplyr::summarise_all(dplyr::funs(round(sum(.,na.rm=T),2)))%>%tibble::as_tibble()
}
polyData<-tidyr::gather(polyDatax,key=key,value=value,-(subRegCol))%>%
tidyr::separate(col="key",into=namesGrid[!namesGrid %in% c("lat","lon","value")],sep="_")
for(colx in names(polyData)){
if(is.character(polyData[[colx]])){
polyData[[colx]]<-gsub("XSPACEX"," ",polyData[[colx]])
polyData[[colx]]<-gsub("XPERIODX","\\.",polyData[[colx]])
polyData[[colx]]<-gsub("XDASHX","\\-",polyData[[colx]])
polyData[[colx]]<-gsub("XLPARENTHX","\\(",polyData[[colx]])
polyData[[colx]]<-gsub("XRLPARENTHX","\\)",polyData[[colx]])
polyData[[colx]]<-gsub("XUNDERX","\\_",polyData[[colx]])
}
}
polyData<-polyData%>%dplyr::mutate(subRegType=subRegType)
polyx<-shape
polyx@data<-dplyr::left_join(polyx@data,polyData)
polyx@data<-polyx@data%>%
dplyr::rename(subRegion:= !!paste(subRegCol))%>%
dplyr::mutate(region=boundaryRegionsSelect)%>%
dplyr::filter(!is.na(x))
poly<-dplyr::bind_rows(poly,polyx@data)
} # Close loop for aggType
} # Close loop for param_i
} # Close loop for scenario_i
paste("Aggregation for all scenarios and params complete.")
}else{print("No grid provided.")}
# Save Cropped Grid
if(nrow(gridCropped)>0){
gridCropped<-tidyr::gather(gridCropped,key=key,value=value,-c(lat,lon))%>%
tidyr::separate(col="key",into=namesGrid[!namesGrid %in% c("lat","lon","value")],sep="_")%>%
unique()
for(colx in names(gridCropped)){
if(is.character(gridCropped[[colx]])){
gridCropped[[colx]]<-gsub("XSPACEX"," ",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XPERIODX","\\.",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XDASHX","\\-",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XLPARENTHX","\\(",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XRLPARENTHX","\\)",gridCropped[[colx]])
gridCropped[[colx]]<-gsub("XUNDERX","\\_",gridCropped[[colx]])
}
}
polyType=subRegType
if (!dir.exists(paste(dirOutputs, "/Grids", sep = ""))){dir.create(paste(dirOutputs, "/Grids", sep = ""))}
data.table::fwrite(gridCropped%>%dplyr::mutate(region=boundaryRegionsSelect,polyType=polyType),
file = paste(dirOutputs, "/Grids/gridCropped_",boundaryRegionsSelect,"_",polyType,nameAppend,".csv", sep = ""),row.names = F)
print(paste("Subregional grid data files written to: ",dirOutputs, "/Grids/gridCropped_",boundaryRegionsSelect,"_",polyType,nameAppend,".csv", sep = ""))
} # If nrow(gridCropped)
#----------------
# Save template, csv and .RDATA
#---------------
if(nrow(poly)>0){
if (!dir.exists(paste(getwd(),"/dataFiles", sep = ""))){
dir.create(paste(getwd(),"/dataFiles", sep = ""))}  # dataFiles directory (should already exist)
if (!dir.exists(paste(getwd(),"/dataFiles/mapping", sep = ""))){
dir.create(paste(getwd(),"/dataFiles/mapping", sep = ""))}  # mapping directory
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(param,units,class,classPalette),
file = paste(getwd(),"/dataFiles/mapping/template_subRegional_mapping.csv", sep = ""),row.names = F)
for (boundaryRegionsSelect in boundaryRegionsSelect[(boundaryRegionsSelect %in% unique(poly$region))]) {
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(scenario,param,units,class,value,x,subRegion,subRegType,region)%>%
dplyr::mutate(value=0,x=2015)%>%unique,
file = paste(dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_",subRegType,"_template",nameAppend,".csv", sep = ""),row.names = F)
data.table::fwrite(poly %>% dplyr::filter(region == boundaryRegionsSelect) %>%
dplyr::select(dplyr::contains("scenario"),param,units,class,value,x,subRegion,subRegType,region,classPalette),
file = paste(dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""),row.names = F)
}
print(paste("Subregional Polygon template .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_",boundaryRegionsSelect,"_template",nameAppend,".csv", sep = ""))
print(paste("Subregional Polygon data .csv files written to: ",dirOutputs, "/Maps/Tables/subReg_origData_byClass_",boundaryRegionsSelect,"_",subRegType,"_origDownscaled",nameAppend,".csv", sep = ""))
}else{print("Polygon data has 0 rows")}
return(poly)
} # Close Function
grid_i=gridMetis
boundaryRegionsSelect_i="Colombia"
subRegShpFolder_i = paste(getwd(),"/dataFiles/gis/admin_Colombia",sep = "")
subRegShpFile_i = paste("colombiaNE1",sep= "")
subRegCol_i = "name"
subRegType_i = "state"
nameAppend_i = "_NE"
aggType_i = NULL
paramsSelect_i= "All" #"demeterLandUse"
sqliteUSE_i = T
sqliteDBNamePath_i = paste(getwd(),"/outputs/Grids/gridMetis.sqlite", sep = "")
grid2polyX<-metis.grid2poly(#grid=grid_i,
boundaryRegionsSelect=boundaryRegionsSelect_i,
subRegShpFolder=subRegShpFolder_i,
subRegShpFile=subRegShpFile_i,
subRegCol=subRegCol_i,
subRegType = subRegType_i,
aggType=aggType_i,
nameAppend=nameAppend_i,
paramsSelect = paramsSelect_i,
sqliteUSE = sqliteUSE_i,
sqliteDBNamePath = sqliteDBNamePath_i)
#----------------------------
# Install necessary packages
#----------------------------
if("devtools" %in% rownames(installed.packages()) == F){install.packages("devtools")}
library(devtools)
if("metis" %in% rownames(installed.packages()) == F){install_github(repo="zarrarkhan/metis")}
library(metis)
if("rgcam" %in% rownames(installed.packages()) == F){install_github(repo="JGCRI/rgcam")}
library(rgcam)
if("tibble" %in% rownames(installed.packages()) == F){install.packages("tibble")}
library(tibble)
if("dplyr" %in% rownames(installed.packages()) == F){install.packages("dlpyr")}
library(dplyr)
if("rgdal" %in% rownames(installed.packages()) == F){install.packages("rgdal")}
library(rgdal)
if("tmap" %in% rownames(installed.packages()) == F){install.packages("tmap")}
library(tmap)
if("rgeos" %in% rownames(installed.packages()) == F){install.packages("rgeos")}
library(rgeos)
#---------------
#  Polygons
#----------------
NE0<-readOGR(dsn=paste(getwd(),"/dataFiles/gis/naturalEarth",sep=""),
layer="ne_10m_admin_0_countries",use_iconv=T,encoding='UTF-8')
NE1<-readOGR(dsn=paste(getwd(),"/dataFiles/gis/naturalEarth",sep=""),
layer="ne_10m_admin_1_states_provinces",use_iconv=T,encoding='UTF-8')
GCAMBasins<-readOGR(dsn=paste(getwd(),"/dataFiles/gis/basin_GCAM",sep=""),
layer="Global235_CLM_final_5arcmin_multipart",use_iconv=T,encoding='UTF-8')
#metis.map(GCAMBasins,fillColumn = "basin_name",facetsON = F,printFig = F)
projX<-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
NE0<-spTransform(NE0,CRS(projX))
NE1<-spTransform(NE1,CRS(projX))
GCAMBasins<-spTransform(GCAMBasins,CRS(projX))
regionIn =
countryXNE0<-NE0[(NE0$NAME==regionOut),]
head(countryXNE0@data)
plot(countryXNE0)
hydrobasinsLev3<-readOGR(dsn=paste(getwd(),"/dataFiles/gis/subbasin_hydrobasin",sep=""),
layer="hydrobasins_level_3",use_iconv=T,encoding='UTF-8')
hydrobasinsLev3<-spTransform(hydrobasinsLev3,CRS(projX))
head(hydrobasinsLev3)
head(hydrobasinsLev3@data)
qtm(hydrobasinsLev3,fill=HYBAS_ID,labels=T)
# Check a plot
NE0crop<-NEO[NEO$NAME=="Argentina"]
